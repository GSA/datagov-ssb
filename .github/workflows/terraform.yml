# On pull request events, this workflow will run `terraform init`, `terraform
# fmt`, and `terraform plan`. On push events to the main branch, `terraform
# apply` will be executed.

name: 'Terraform'

on:
  push:
    branches:
    - main
  pull_request:

env:
  # All environments
  # For storing the Terraform state for the deployment
  AWS_ACCESS_KEY_ID: "${{ secrets.AWS_ACCESS_KEY_ID }}"
  AWS_SECRET_ACCESS_KEY: "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
  # For deploying and registering the broker in Cloud Foundry
  TF_VAR_cf_username: "${{ secrets.TF_VAR_cf_username }}"
  TF_VAR_cf_password: "${{ secrets.TF_VAR_cf_password }}"

  # Per environment
  # For managing brokered resources via the AWS brokerpak
  TF_VAR_aws_access_key_id: "${{ secrets.TF_VAR_aws_access_key_id }}"
  TF_VAR_aws_secret_access_key: "${{ secrets.TF_VAR_aws_secret_access_key }}"

jobs:
  review:
    name: 'Terraform linting and review'
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Prepare the application
      run: ./app-setup.sh
    
    # Supply a (empty) .env.secrets file
    - name: Supply .env.secrets
      run: touch .env.secrets
    # Initialize the Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      id: init
      env:
        BUCKET: "${{ secrets.BUCKET }}"
        KEY: "ssb-tfstate"
        REGION: "us-gov-west-1"
        ENCRYPT: "true"
      # run: cat > backend.tfvars << EOT
      #   ${{ env.BACKEND_TFVARS }}
      # EOT
      run: > 
        docker-compose run --rm 
        terraform init 
        -backend-config=bucket="${{ env.BUCKET }}" 
        -backend-config=key="${{ env.KEY }}" 
        -backend-config=region="${{ env.REGION }}" 
        -backend-config=encrypt="${{ env.ENCRYPT }}"
        -backend-config=access_key="${{ secrets.AWS_ACCESS_KEY_ID }}"
        -backend-config=secret_key="${{ secrets.AWS_SECRET_ACCESS_KEY }}"

    # Check that all Terraform configuration files adhere to the canonical format
    - name: Terraform Format
      run: docker-compose run --rm terraform fmt -check

    # Check that all Terraform configuration is semantically valid
    - name: Terraform Validate
      run: docker-compose run --rm terraform validate

    # Generate an execution plan for Terraform
    - name: Terraform Plan (staging)
      id: plan-staging
      if: github.event_name == 'pull_request'
      env:
        TF_WORKSPACE: staging
      run: |
        tfplan_file=$(mktemp)
        docker-compose run --rm  \
          -e AWS_ACCESS_KEY_ID  \
          -e AWS_SECRET_ACCESS_KEY \
          -e TF_VAR_cf_username \
          -e TF_VAR_cf_password \
          -e TF_VAR_aws_access_key_id \
          -e TF_VAR_aws_secret_access_key \
          terraform plan -no-color | tee $tfplan_file
        echo "::set-output name=tfplan::$tfplan_file"
      continue-on-error: true  # Make sure to post the error to the PR

    # Generate an execution plan for Terraform
    - name: Terraform Plan (production)
      id: plan-production
      if: github.event_name == 'pull_request'
      env:
        TF_WORKSPACE: default
      run: |
        tfplan_file=$(mktemp)
        docker-compose run --rm  \
          -e AWS_ACCESS_KEY_ID  \
          -e AWS_SECRET_ACCESS_KEY \
          -e TF_VAR_cf_username \
          -e TF_VAR_cf_password \
          -e TF_VAR_aws_access_key_id \
          -e TF_VAR_aws_secret_access_key \
          terraform plan -no-color | tee $tfplan_file
        echo "::set-output name=tfplan::$tfplan_file"
      continue-on-error: true  # Make sure to post the error to the PR

    - name: Update Pull Request
      uses: actions/github-script@v3
      if: github.event_name == 'pull_request'
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const plan_staging = fs.readFileSync('${{ steps.plan-staging.outputs.tfplan }}', {encoding: 'utf8'});
          const plan_production = fs.readFileSync('${{ steps.plan-production.outputs.tfplan }}', {encoding: 'utf8'});
          const output = `#### Terraform Format and Style üñå\`${{ steps.fmt.outcome }}\`
          #### Terraform Initialization ‚öôÔ∏è\`${{ steps.init.outcome }}\`
          #### Staging Plan üìñ\`${{ steps.plan-staging.outcome }}\`
          <details><summary>Show staging plan</summary>

          \`\`\`terraform
          ${plan_staging}
          \`\`\`

          </details>

          #### Production Plan üìñ\`${{ steps.plan-production.outcome }}\`
          <details><summary>Show production plan</summary>

          \`\`\`terraform
          ${plan_production}
          \`\`\`

          </details>

          *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;

          github.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: output
          });

    - name: Terraform Plan Status
      if: steps.plan-staging.outcome == 'failure' || steps.plan-production.outcome == 'failure'
      run: exit 1


  deploy-staging:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    name: 'Deploy Terraform'
    runs-on: ubuntu-latest
    environment: staging
    needs:
      - review
    env:
      TF_WORKSPACE: staging

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    # Checkout the repository to the GitHub Actions runner
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Prepare the application
      run: ./app-setup.sh

    # Supply a (empty) .env.secrets file
    - name: Supply .env.secrets
      run: touch .env.secrets

    # Initialize the Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      id: init
      env:
        BUCKET: "${{ secrets.BUCKET }}"
        KEY: "ssb-tfstate"
        REGION: "us-gov-west-1"
        ENCRYPT: "true"
      # run: cat > backend.tfvars << EOT
      #   ${{ env.BACKEND_TFVARS }}
      # EOT
      run: > 
        docker-compose run --rm 
        terraform init 
        -backend-config=bucket="${{ env.BUCKET }}" 
        -backend-config=key="${{ env.KEY }}" 
        -backend-config=region="${{ env.REGION }}" 
        -backend-config=encrypt="${{ env.ENCRYPT }}"
        -backend-config=access_key="${{ secrets.AWS_ACCESS_KEY_ID }}"
        -backend-config=secret_key="${{ secrets.AWS_SECRET_ACCESS_KEY }}"

    # Uncomment the following step to get an interactive debugging session!
    # Use the SSH key on your GitHub account to ssh to the address displayed in
    # the Action's logs.
#    - name: Start debugging session
#      uses: mxschmitt/action-tmate@v3
#      with:
#        limit-access-to-actor: true

      # On push to main, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      run: |
        docker-compose run --rm \
        -e AWS_ACCESS_KEY_ID  \
        -e AWS_SECRET_ACCESS_KEY \
        -e TF_VAR_cf_username \
        -e TF_VAR_cf_password \
        -e TF_VAR_aws_access_key_id \
        -e TF_VAR_aws_secret_access_key \
        terraform apply -auto-approve
    - name: Test
      run: echo ok  # TODO staging smoke test

  deploy-production:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    name: 'Deploy Terraform'
    runs-on: ubuntu-latest
    environment: production
    needs:
      - deploy-staging
    env:
      TF_WORKSPACE: default

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash

    # Checkout the repository to the GitHub Actions runner
    steps:
    - name: Checkout
      uses: actions/checkout@v2
    - name: Prepare the application
      run: ./app-setup.sh

    # Supply a (empty) .env.secrets file
    - name: Supply .env.secrets
      run: touch .env.secrets

    # Initialize the Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
    - name: Terraform Init
      id: init
      env:
        BUCKET: "${{ secrets.BUCKET }}"
        KEY: "ssb-tfstate"
        REGION: "us-gov-west-1"
        ENCRYPT: "true"
      # run: cat > backend.tfvars << EOT
      #   ${{ env.BACKEND_TFVARS }}
      # EOT
      run: > 
        docker-compose run --rm 
        terraform init 
        -backend-config=bucket="${{ env.BUCKET }}" 
        -backend-config=key="${{ env.KEY }}" 
        -backend-config=region="${{ env.REGION }}" 
        -backend-config=encrypt="${{ env.ENCRYPT }}"
        -backend-config=access_key="${{ secrets.AWS_ACCESS_KEY_ID }}"
        -backend-config=secret_key="${{ secrets.AWS_SECRET_ACCESS_KEY }}"

    # Uncomment the following step to get an interactive debugging session!
    # Use the SSH key on your GitHub account to ssh to the address displayed in
    # the Action's logs.
#    - name: Start debugging session
#      uses: mxschmitt/action-tmate@v3
#      with:
#        limit-access-to-actor: true

      # On push to main, build or change infrastructure according to Terraform configuration files
      # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      run: |
        docker-compose run --rm \
        -e AWS_ACCESS_KEY_ID  \
        -e AWS_SECRET_ACCESS_KEY \
        -e TF_VAR_cf_username \
        -e TF_VAR_cf_password \
        -e TF_VAR_aws_access_key_id \
        -e TF_VAR_aws_secret_access_key \
        terraform apply -auto-approve
